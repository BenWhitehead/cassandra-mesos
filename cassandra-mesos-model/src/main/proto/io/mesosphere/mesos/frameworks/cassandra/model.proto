/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.mesosphere.mesos.frameworks.cassandra;

option java_outer_classname = "CassandraFrameworkProtos";

message CassandraFrameworkConfiguration {
    optional string frameworkId = 1;
    optional string frameworkName = 2;
    optional int64 healthCheckIntervalSeconds = 8;
    optional int64 bootstrapGraceTimeSeconds = 10;
    repeated PortMapping portMapping = 11;

    // default configuration
    required CassandraConfigRole defaultConfigRole = 6;
}

// CassandraConfigRole is currently only used once. But different nodes may require different sizings -
// e.g. when replacing old metal with new metal. Different DCs may also have different sizings.
// Individual nodes just reference a "config role".
message CassandraConfigRole {
    // arbitrary name of this configuration - usually "default" but could be something like "16core-128g-4x500gSSD"
    optional string name = 1;

    optional string cassandraVersion = 2;
    optional int32 numberOfNodes = 3;
    optional double cpuCores = 4;
    optional int64 diskMb = 6;
    optional int32 numberOfSeeds = 7;


    // total memory required (must be greater than memJavaHeapMb + memAssumeOffHeapMb)
    optional int64 memMb = 5;

    // Cassandra memory usage can be categorized into
    // 1. Java heap (MAX_HEAP_SIZE) - including new-gen (HEAP_NEWSIZE)
    //    Amount of Java heap in MB.
    //    (defaults to 50% of memMb, max 16384, if not present)
    optional int64 memJavaHeapMb = 8;
    // 2. Off-Heap
    //    Amount of Off heap in MB.
    //    (defaults to memMb - memJavaHeapMb, if not present)
    optional int64 memAssumeOffHeapMb = 9;
    // 3. OS (add as much as possible for OS block cache)
    //    This is just the difference between memMb and memJavaHeapMb + memAssumeOffHeapMb

    // Production grade memory configuration should include all three memory configuration parameters above.
    // Do not forget to add as much memory for OS block cache as possible for improved performance.

    // Off-heap structures (C* 2.1):
    // - index-summary (default: 5% of the heap size)
    //   configured in cassandra.yaml - see index_summary_capacity_in_mb
    //   default to 5% of the heap size (may exceed)
    // - key-cache (default: 5% of the heap size)
    //   configured in cassandra.yaml - see key_cache_size_in_mb
    //   default to 5% of the heap size
    // - row-cache (default: off)
    //   configured in cassandra.yaml - see row_cache_size_in_mb (must be explicitly enabled in taskEnv)
    //   default to 0
    // - counter-cache (default: min(2.5% of Heap (in MB), 50MB))
    //   configured in cassandra.yaml - see counter_cache_size_in_mb
    //   default: min(2.5% of Heap (in MB), 50MB) ; 0 means no cache
    // - memtables (default on-heap)
    //   configured in cassandra.yaml - see file_cache_size_in_mb
    //   default to the smaller of 1/4 of heap or 512MB
    // - file-cache (default: min(25% of Heap (in MB), 512MB))
    //   configured in cassandra.yaml - see file_cache_size_in_mb
    //   default to the smaller of 1/4 of heap or 512MB
    // - overhead during flushes/compactions/cleanup
    //   implicitly defined by workload

    // additional configuration
    // process environment
    optional TaskEnv taskEnv = 10;
    // cassandra.yaml configuration
    optional TaskConfig cassandraYamlConfig = 11;
}

message PortMapping {
    required string name = 1;
    required int32 port = 2;
}

message CassandraClusterState {
    repeated CassandraNode nodes = 1;
    repeated ExecutorMetadata executorMetadata = 2;
    optional int64 lastServerLaunchTimestamp = 3;
}

message CassandraClusterHealthCheckHistory {
    required int32 maxEntriesPerNode = 1;
    repeated HealthCheckHistoryEntry entries = 2;
}

message HealthCheckHistoryEntry {
    required string executorId = 1;
    required int64 timestampStart = 2;
    required int64 timestampEnd = 3;
    required HealthCheckDetails details = 4;
}

enum ClusterJobType {
    CLEANUP = 1;
    REPAIR = 2;
}
message CassandraClusterJobs {
    repeated ScheduledJob jobs = 1;

    optional ClusterJobStatus currentClusterJob = 3;
    repeated ClusterJobStatus lastClusterJobs = 4;
}
message ScheduledJob {
    required ClusterJobType jobType = 1;
    required int64 scheduledTime = 2;
    optional RepairScheduledJob repairTask = 3;
    optional CleanupScheduledJob cleanupTask = 4;
}
message CleanupScheduledJob {
}
message RepairScheduledJob {
}
message ClusterJobStatus {
    required ClusterJobType jobType = 1;
    required int64 startedTimestamp = 2;
    optional int64 finishedTimestamp = 3;
    repeated string remainingNodes = 4;
    repeated NodeJobStatus completedNodes = 5;
    optional bool aborted = 6;
    optional NodeJobStatus currentNode = 7;
}
message NodeJobStatus {
    required string executorId = 1;
    required string taskId = 2;
    required ClusterJobType jobType = 3;
    optional int64 startedTimestamp = 4;
    optional int64 finishedTimestamp = 5;
    optional bool running = 6;
    optional bool failed = 7;
    optional string failureMessage = 8;

    repeated ClusterJobKeyspaceStatus processedKeyspaces = 9;
    repeated string remainingKeyspaces = 10;
}
message ClusterJobKeyspaceStatus {
    required string keyspace = 1;
    required string status = 2;
    required int64 duration = 3;
}

message CassandraNode {
    required string hostname = 1;
    required string ip = 2;
    required JmxConnect jmxConnect = 3;

    repeated DataVolume dataVolumes = 4;
    optional CassandraNodeExecutor cassandraNodeExecutor = 5;

    repeated CassandraNodeTask tasks = 6;

    required bool seed = 8;
    optional int64 lastRepairTimestamp = 9;
    optional int64 lastCleanupTimestamp = 10;

    // Indicates whether a node should run or not.
    required TargetRunState targetRunState = 11;

    optional int32 cassandraDaemonPid = 12;

    enum TargetRunState {
        // If the server task is not active, it is started.
        // Note that general bootstrap-grace-time settings and other checks (e.g. currently other nodes joining) apply.
        RUN = 0;
        // If the server-task is active, a server-task shutdown is initiated.
        STOP = 1;
        // If the server task is not active, the state is immediately set to RUN.
        // If the server-task is active, a server-task shutdown is initiated.
        // Note that general bootstrap-grace-time settings and other checks (e.g. currently other nodes joining) apply.
        RESTART = 2;
    }
}
message DataVolume {
    required string path = 1;
    required int64 sizeMb = 2;
}
message CassandraNodeExecutor {
    required string executorId = 1;
    required string source = 2;
    required double cpuCores = 3;
    required int64 memMb = 4;
    required int64 diskMb = 5;
    repeated int64 ports = 6;

    required string command = 7;
    repeated string commandArgs = 8;

    optional TaskEnv taskEnv = 9;

    repeated URI resource = 10;
}
message URI {
    required string value = 1;
    optional bool executable = 2;
    optional bool extract = 3;
}

message CassandraNodeTask {
    required TaskType taskType = 1;
    required string taskId = 2;
    required string executorId = 3;
    required double cpuCores = 4;
    required int64 memMb = 5;
    required int64 diskMb = 6;
    repeated int64 ports = 7;

    optional TaskDetails taskDetails = 8;

    enum TaskType {
        METADATA = 1;
        SERVER = 2;
        CLUSTER_JOB = 3;
    }
}

message TaskDetails {
    required TaskType taskType = 1;
    optional ExecutorMetadataTask executorMetadataTask = 2;
    optional CassandraServerRunTask cassandraServerRunTask = 3;
    optional NodeJobTask nodeJobTask = 4;

    enum TaskType {
        EXECUTOR_METADATA = 1;
        CASSANDRA_SERVER_RUN = 2;
        HEALTH_CHECK = 3;
        NODE_JOB = 4;
        NODE_JOB_STATUS = 5;
    }
}

message ExecutorMetadataTask {
    required string executorId = 1;
    required string ip = 2;
}

message CassandraServerRunTask {
    required string version = 1;
    repeated string command = 2;
    optional TaskEnv taskEnv = 3;
    repeated TaskFile taskFiles = 4;
    required TaskConfig taskConfig = 5;
    required JmxConnect jmx = 6;
}

message NodeJobTask {
    required ClusterJobType jobType = 1;
}

message JmxConnect {
    required int32 jmxPort = 1;
    required string ip = 2;
    // TODO add JMX auth params
}

/**
 * Describes a File that needs to be created/overwritten at the specified outputPath
 * with provided data
 */
message TaskFile {
    required string outputPath = 1;
    required bytes data = 2;
}

message TaskConfig {
    message Entry {
        required string name = 1;
        optional string stringValue = 2;
        optional int64 longValue = 3;
    }

    repeated Entry variables = 1;
}

/**
 * Describes a collection of environment variables.
 */
message TaskEnv {
    message Entry {
        required string name = 1;
        required string value = 2;
    }

    repeated Entry variables = 1;
}

message SlaveStatusDetails {
    required StatusDetailsType statusDetailsType = 1;
    optional ExecutorMetadata executorMetadata = 2;
    optional CassandraServerRunMetadata cassandraServerRunMetadata = 3;
    optional SlaveErrorDetails slaveErrorDetails = 4;
    optional HealthCheckDetails healthCheckDetails = 5;
    optional NodeJobStatus nodeJobStatus = 6;

    enum StatusDetailsType {
        NULL_DETAILS = 1;
        EXECUTOR_METADATA = 2;
        CASSANDRA_SERVER_RUN = 3;
        ERROR_DETAILS = 4;
        HEALTH_CHECK_DETAILS = 5;
        NODE_JOB_STATUS = 6;
    }
}

message ExecutorMetadata {
    required string executorId = 1;
    optional string ip = 2;
}

message CassandraServerRunMetadata {
    required int32 pid = 1;
}

message SlaveErrorDetails {
    optional string msg = 1;
    optional string details = 2;
    optional ErrorType errorType = 3;
    optional int32 processExitCode = 4;

    enum ErrorType {
        // cassandra server process is not runnning but is expected to be
        PROCESS_NOT_RUNNING = 1;
        // cassandra server process exited
        PROCESS_EXITED = 2;
        // protobuf (de)serialization failed
        PROTOCOL_VIOLATION = 3;
        // another node job is still running
        ANOTHER_JOB_RUNNING = 4;
        // failed to start task
        TASK_START_FAILURE = 5;
    }
}

message HealthCheckDetails {
    required bool healthy = 1;
    optional string msg = 2;
    optional NodeInfo info = 3;
}

message NodeInfo {
    // extracted this information because it could be meaningful outside of a health-check
    optional string clusterName = 1;
    optional string operationMode = 2;
    optional bool joined = 3;
    optional bool rpcServerRunning = 4;
    optional bool nativeTransportRunning = 5;
    optional bool gossipInitialized = 6;
    optional bool gossipRunning = 7;
    optional int64 uptimeMillis = 8;
    optional string hostId = 9;
    optional string endpoint = 10;
    optional int32 tokenCount = 11;
    optional string dataCenter = 12;
    optional string rack = 13;
    optional string version = 14;
}
